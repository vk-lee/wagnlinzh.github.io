<!DOCTYPE html>
<html>
    <head>
    <!-- Title -->
    
    <title>
        JavaScript高级程序设计 Notes (对象创建和继承) | wanglinzhizhi
    </title>
    
    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">
    
    <!-- Meta & INfo -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="wanglinzhizhi">
    <meta name="description" content="游走在上下文无关文法间">
    <meta name="keywords" content="null">
    
    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">
    
    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="wanglinzhizhi">
    
    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://www.wanglinzhizhi.me">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="JavaScript高级程序设计 Notes (对象创建和继承) | wanglinzhizhi">
    <meta property="og:description" content="游走在上下文无关文法间">
    
     <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">
        
        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->
    
    <!-- Import CSS -->
    <link rel="stylesheet" href="/css/material.min.css">
    <link rel="stylesheet" href="/css/style.min.css">
    <!-- Config CSS -->


<!-- Other Styles -->
<style>
	body, html{
		font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
	}
	
    a{
        color: #00838F
    }
    
    .mdl-card__media,
    #search-label,
    #search-form-label:after,
    #scheme-Paradox .hot_tags-count,
    #scheme-Paradox .sidebar_archives-count,
    #scheme-Paradox .sidebar-colored .sidebar-header,
    #scheme-Paradox .sidebar-colored .sidebar-badge{
        background-color: #0097A7 !important
    }
    
	/* Sidebar User Drop Down Menu Text Color */
	#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
    #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus{
        color: #0097A7 !important
    }
    
    #post_entry-right-info,
    .sidebar-colored .sidebar-nav li:hover > a,
    .sidebar-colored .sidebar-nav li:hover > a i,
    .sidebar-colored .sidebar-nav li > a:hover,
    .sidebar-colored .sidebar-nav li > a:hover i,
    .sidebar-colored .sidebar-nav li > a:focus i,
    .sidebar-colored .sidebar-nav > .open > a,
    .sidebar-colored .sidebar-nav > .open > a:hover,
    .sidebar-colored .sidebar-nav > .open > a:focus,
    #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a{
        color: #0097A7 !important
    }
    
    .toTop{
        background: #757575 !important
    }
		
	.material-layout .material-post>.material-nav,
	.material-layout .material-index>.material-nav,
	.material-nav a{
		color: #757575;
	}
		
	#scheme-Paradox .MD-burger-layer {
		background-color: #757575;
	}

	#scheme-Paradox #post-toc-trigger-btn{
		color: #757575;
	}
	
	.post-toc a:hover{
		color: #00838F;
		text-decoration: underline;
	}
</style>


<!-- Theme Background Related-->

    <style>
        body{
            background-color: #F5F5F5
        }
		
		/* blog_info bottom background */
        #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
            background-color: #fff;
        }
    </style>




<!-- Fade Effect -->

    <style>
        .fade {
            transition: all 800ms linear;
            -webkit-transform: translate3d(0,0,0);
            -moz-transform: translate3d(0,0,0);
            -ms-transform: translate3d(0,0,0);
            -o-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
            opacity: 1;
        }

        .fade.out{
            opacity: 0;
        }
    </style>

	<script src="/js/jquery.min.js"></script>
	
	<link rel="stylesheet" href="/css/highlight/atom-one-dark.css">
	
	<!-- UC Browser Compatible-->
	<script>
		var agent = navigator.userAgent.toLowerCase();
		if(agent.indexOf('ucbrowser')>0) {
			document.write('<link rel="stylesheet" href="/css/uc.css">');
		   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
		}
	</script>
    
    <!-- Custom Head -->
    
</head>
	
	

    <body id="scheme-Paradox">

		
        <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
				
			
			
            <!-- Main Container -->
            <main class="material-layout__content" id="main">
				
                <!-- Top Anchor -->
                <div id="top"></div>
				
				
                <!-- Hamburger Button -->
                <button class="MD-burger-icon sidebar-toggle">
                    <span class="MD-burger-layer"></span>
                </button>
				
				
                <!-- Post TOC -->

    
	<!-- Back Button -->
<!--
	<div class="material-back" id="backhome-div" tabindex="0">
		<a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" href="#" onclick="window.history.back();return false;" target="_self" role="button" data-upgraded=",MaterialButton,MaterialRipple">
			<i class="material-icons" role="presentation">arrow_back</i>
			<span class="mdl-button__ripple-container">
				<span class="mdl-ripple"></span>
			</span>
		</a>
	</div>			
-->
	<!-- Left aligned menu below button -->
	<button id="post-toc-trigger-btn"
			class="mdl-button mdl-js-button mdl-button--icon">
	  <i class="material-icons">format_list_numbered</i>
	</button>

	<ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect"
		for="post-toc-trigger-btn">
			
			<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript高级程序设计-Notes"><span class="post-toc-number">1.</span> <span class="post-toc-text">JavaScript高级程序设计 Notes</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建一个新对象的方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">创建一个新对象的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-工厂模式"><span class="post-toc-number">3.</span> <span class="post-toc-text">1.工厂模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-构造函数模式"><span class="post-toc-number">4.</span> <span class="post-toc-text">2.构造函数模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-原型模式"><span class="post-toc-number">5.</span> <span class="post-toc-text">3. 原型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型对象的问题"><span class="post-toc-number">6.</span> <span class="post-toc-text">原型对象的问题.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-组合使用构造函数模式和原型模式"><span class="post-toc-number">7.</span> <span class="post-toc-text">4. 组合使用构造函数模式和原型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-寄生构造函数模式"><span class="post-toc-number">8.</span> <span class="post-toc-text">6.寄生构造函数模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-稳妥构造函数模式"><span class="post-toc-number">9.</span> <span class="post-toc-text">7.稳妥构造函数模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承"><span class="post-toc-number">10.</span> <span class="post-toc-text">继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1原型继承"><span class="post-toc-number">11.</span> <span class="post-toc-text">#1原型继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谨慎的定义方法"><span class="post-toc-number">12.</span> <span class="post-toc-text">谨慎的定义方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型链继承的问题"><span class="post-toc-number">13.</span> <span class="post-toc-text">原型链继承的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2借用构造函数-继承"><span class="post-toc-number">14.</span> <span class="post-toc-text">#2借用构造函数 继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3组合继承-伪经典继承"><span class="post-toc-number">15.</span> <span class="post-toc-text">#3组合继承.(伪经典继承)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4原型式继承"><span class="post-toc-number">16.</span> <span class="post-toc-text">#4原型式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5寄生式继承"><span class="post-toc-number">17.</span> <span class="post-toc-text">#5寄生式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6寄生组合式继承"><span class="post-toc-number">18.</span> <span class="post-toc-text">#6寄生组合式继承</span></a></li></ol>
		
<!--			<li class="mdl-menu__item">Some Action</li>-->
	</ul>



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">
		
        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
	<!-- Paradox Post Header -->
	
		
			<!-- Random Thumbnail -->
			<div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
				<script>
    
    var randomNum;
    randomNum = Math.floor(Math.random() * 5 + 1);
    
    $(".post_thumbnail-random").css('background-image', 'url(' + '/img/random/' + randomNum + '.png' + ')');
    
</script>

		
	
        <p class="article-headline-p">
            JavaScript高级程序设计 Notes (对象创建和继承)
        </p>
    </div>

	

				
				
					<!-- Paradox Post Info -->
					<div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">
    
    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/me.jpeg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>wanglinzhizhi</strong>
        <span>Feb 08, 2016</span>
    </div>
    
    <div class="section-spacer"></div>
	
    <!-- Favorite -->
<!--
    <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
        <i class="material-icons" role="presentation">favorite</i>
        <span class="visuallyhidden">favorites</span>
    </button>
-->
    
    <!-- Tags (bookmark) -->
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        
    </ul>
    
    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    
    
    <!-- Leancloud Views -->
    <a class="post_share-link" href="#">
        <li class="mdl-menu__item">
            <span id="/2016/02/08/2016-02-08-JavaScript高级程序设计 Notes/" class="leancloud-views_num" data-flag-title="JavaScript高级程序设计 Notes (对象创建和继承)">
     &nbsp;浏览量
</span>
        </li>
    </a>
    
    
    
    
    <!-- Share Twitter -->
    <a class="post_share-link" href="https://twitter.com/intent/tweet?text=JavaScript高级程序设计 Notes (对象创建和继承)&url=http://www.wanglinzhizhi.me//2016/02/08/2016-02-08-JavaScript高级程序设计 Notes/index.html&via=wanglinzhizhi" target="_blank">
        <li class="mdl-menu__item">
            分享到 Twitter
        </li>
    </a>
    
    <!-- Share Google+ -->
    <a class="post_share-link" href="https://plus.google.com/share?url=http://www.wanglinzhizhi.me//2016/02/08/2016-02-08-JavaScript高级程序设计 Notes/index.html" target="_blank">
        <li class="mdl-menu__item">
            分享到 Google+
        </li>
    </a>
    
    <!-- Share Weibo -->
    <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=JavaScript高级程序设计 Notes (对象创建和继承)&url=http://www.wanglinzhizhi.me//2016/02/08/2016-02-08-JavaScript高级程序设计 Notes/index.html&pic=&searchPic=false&style=simple" target="_blank">
        <li class="mdl-menu__item">
            分享到微博
        </li>
    </a>
</ul>
</div>
				

                <!-- Post Content -->
                <div id="post-content" class="markdown-Github mdl-color-text--grey-700 mdl-card__supporting-text fade out">
	
		<h3 id="JavaScript高级程序设计-Notes"><a href="#JavaScript高级程序设计-Notes" class="headerlink" title="JavaScript高级程序设计 Notes"></a>JavaScript高级程序设计 Notes</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生的构造函数,在运行时会自动出现在执行环境中.此外,也可以定义自定义对象类型的属性和方法.</p>
<p><br><br><br><br></p>
<h3 id="创建一个新对象的方法"><a href="#创建一个新对象的方法" class="headerlink" title="创建一个新对象的方法"></a>创建一个新对象的方法</h3><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>) </span>&#123;</div><div class="line">true<span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">trueobj.name=name;</div><div class="line">trueobj.age=age;</div><div class="line">trueobj.job=job;</div><div class="line">trueobj.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">truetruealert(<span class="keyword">this</span>.name);</div><div class="line">true&#125;</div><div class="line">trueretrun obj;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">"wanglin"</span>,<span class="number">24</span>,<span class="string">"front-end"</span>);</div><div class="line"><span class="keyword">var</span> person2=createPerson(<span class="string">'wanglinzhizhi.me'</span>,<span class="number">23</span>,<span class="string">"front-end engreerer"</span>);</div></pre></td></tr></table></figure>
<p>这种方法不好的地方在于,没有解决对象识别的问题(怎样知道一个对象的类型).</p>
<p><br><br><br><br></p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2.构造函数模式"></a>2.构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">true<span class="keyword">this</span>.name=name;</div><div class="line">true<span class="keyword">this</span>.age=age;</div><div class="line">true<span class="keyword">this</span>.job=job;</div><div class="line">true<span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">truetruealert(<span class="keyword">this</span>.name);</div><div class="line">true&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"wanglin"</span>,<span class="number">24</span>,<span class="string">"front-end"</span>);</div><div class="line"><span class="keyword">var</span> person2= Person(<span class="string">'wanglinzhizhi.me'</span>,<span class="number">23</span>,<span class="string">"front-end engreerer"</span>);</div></pre></td></tr></table></figure>
<p>要创建一个新实例,必须使用new 操作符.以这种方式调用构造函数实际上会经历以下4个步骤:</p>
<ul>
<li>创建一个新对象;</li>
<li>将构造函数的作用域附给新对象(因此this就指向了这个对象)</li>
<li>执行构造函数中的代码(为该对象添加属性);</li>
<li>返回新对象</li>
</ul>
<p>构造函数也是函数</p>
<p>构造函数与其他函数唯一的区别,就在于调用它们的方式不同.不过,毕竟构造函数也是函数,不存在定义构造函数特殊的语法.任何函数,只要通过new操作符来调用,那它就可以作为构造含糊;而任何函数,如果不通过new操作符来调用,那它跟普通的函数也不会有什么两样.</p>
<p>而且,一以这种方式定义的构造函数是是定义在Global对象(在浏览器中是window对象)中的.</p>
<p>构造函数的问题</p>
<p>使用构造函数最主要的问题,及时每个方法都要在每个实例上重新创建一遍.在前面的例子中,person2和person1都有一个名为sayName()的方法,但那两个方法不是同一个Function的实例.不要忘了ECMAScript中的函数就是对象,因此没定义一个函数,也就实例化了一个对象.从逻辑上讲,此时的构造函数也可以这样定义.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person(name , age, job)&#123;</div><div class="line">truethis.name=name;</div><div class="line">truethis.age=age;</div><div class="line">truethis.job=job;</div><div class="line">truethis.sayName=new Function(&quot;alert(this.name)&quot;);		//与声明函数在逻辑上是等价的.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个角度更容易明白每个Person实例都包含一个不同的Function实例(以name属性)的本质.说明白些,以这种方式创建函数, 会导致不同的作用域链和标识符解析,但创建Function新实例的机制仍然是相同的.<br>因此,不同实例上的同名函数是不相等的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">person2.sayName === person1.sayName //false</div></pre></td></tr></table></figure>
<p>然而,创建两个完成相同任务的Function实例的确是没有必要.况且又this对象在,根本不用再执行代码前就把函数绑定到特定对象上面. 因此可以把函数定义转移到构造函数外部来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">truethis.name= name;</div><div class="line">truethis.age= age;</div><div class="line">truethis.job= job;</div><div class="line">truethis.sayName= sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayName()&#123;</div><div class="line">truealert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person(&quot;wanglin&quot;,24,&quot;front-end&quot;);</div><div class="line">var person2=new Person(&quot;wanglinzhizhi&quot;,23,&quot;front-end&quot;);</div></pre></td></tr></table></figure>
<p>但是又有新的问题,全局作用域中定义的函数实际上只能被某个对象滴哦啊用.而且,如果对象需要定义很多方法,那么就要定义很多个全局函数,于是我们这个定义的引用类型就丝毫没有封装性可言了.</p>
<p><br><br><br><br></p>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>多个对象实例共享原型所保存的属性和方法的基本原理.原型链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">truetrue</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化</div><div class="line">Person.prototype.name = &quot;wanglin&quot;;</div><div class="line">Person.prototype.age=&quot;24&quot;;</div><div class="line">Person.prototype.job=&quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName=function()&#123;</div><div class="line">truealert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var person2=new Person();</div><div class="line">person2.sayName();</div><div class="line"></div><div class="line">var person1= new Person();</div><div class="line">person1.sayName();</div><div class="line"></div><div class="line">person1.sayName===person2.sayName;  //true</div></pre></td></tr></table></figure>
<p>在为对象添加一个属性时,这个属性就会屏蔽原型中保存的同名属性;换句话说, 添加这个属性只会阻止我们访问原型中的那个属性,但不会修改那个属性.即使将这个属性设置为null,也只会在实例中设置这个属性,而不会恢复其指向原型的链接.</p>
<p>但是, 使用delete 操作符则可以完全删除实例属性,从而让我们能够重新访问原型中的属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化</div><div class="line">Person.prototype.name = &quot;wanglin&quot;;</div><div class="line">Person.prototype.age=&quot;24&quot;;</div><div class="line">Person.prototype.job=&quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName=function()&#123;</div><div class="line">truealert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person();</div><div class="line">var person2=new	Person();</div><div class="line"></div><div class="line">person1.name=&quot;wanglinzhizhi&quot;;</div><div class="line">alert(person1.name);	//wanglinzhizhi</div><div class="line">alert(person2.name);	//wanglin</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);	//wanglin</div></pre></td></tr></table></figure>
<p>更简单的原型写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person( ) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">truename:&quot;wanglin&quot;,</div><div class="line">trueage:25,</div><div class="line">truejob:&quot;front-end&quot;,</div><div class="line">truesayName:function()&#123;</div><div class="line">truetruealert(this.name);</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person();</div></pre></td></tr></table></figure>
<p>Notes:这么做是有坑的。此时的contructor属性不在指向Person了.每创建一个函数就会同时创建它的prototype对象,因此constuctor属性也就变成了新对象的constructor属性(指向Object构造函数), 不再指向Person函数.</p>
<p>如果constructor的值真的很重要,可以继续修改,使其设置回适当的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">true</div><div class="line">trueconstructor: Person,</div><div class="line"></div><div class="line">truename:&quot;wanglin&quot;,</div><div class="line">trueage:25,</div><div class="line">truejob:&quot;front-end&quot;,</div><div class="line">truesayName:function()&#123;</div><div class="line">truetruealert(this.name);</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person();</div></pre></td></tr></table></figure>
<p>我们回过头想想,构造函数的值到底重要吗?</p>
<p>而这样修改之后,会导致它的[[Enumrable]]特性被设置为true.</p>
<p><br><br><br><br></p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题."></a>原型对象的问题.</h3><p>对于包含引用类型值的属性来说,问题很突出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">true</div><div class="line">trueconstructor: Person,</div><div class="line"></div><div class="line">truename:&quot;wanglin&quot;,</div><div class="line">trueage:25,</div><div class="line">truejob:&quot;front-end&quot;,</div><div class="line">truefriends:[&quot;Shelby&quot;,&quot;Court&quot;],</div><div class="line">truesayName:function()&#123;</div><div class="line">truetruealert(this.name);</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var person1=new Person();</div><div class="line">var person2=new	Person();</div><div class="line"></div><div class="line">person1.friends.push(&quot;wanglinzhizhi&quot;);</div><div class="line">alert(person1.friends);	//&quot;Shelby,Court wanglinzhizhi&quot;</div><div class="line">alert(person2.friends);	//&quot;Shelby,Court wanglinzhizhi&quot;</div><div class="line"></div><div class="line">alert(person1.friends===person2.friends);//true</div></pre></td></tr></table></figure>
<p><br><br><br><br></p>
<h3 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4. 组合使用构造函数模式和原型模式"></a>4. 组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式,就是组合使用构造函数模式与原型模式.</p>
<blockquote>
<p>构造函数模式用于定义实例属性,而原型模式用于定义方法和共享属性.</p>
</blockquote>
<p>最终,每个实例都会有自己的一份实例属性的副本,但同时又共享着对方法的引用,最大限度地节省了内存.另外,这种混成模式还可支持向构造函数传递参数;可谓集二者之所长.</p>
<p>这种方法主要对应的情况是 对象中有引用类型的情况.(把引用类型定义在构造函数中).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">function Person(name, age, job)&#123;</div><div class="line">truethis.name= name;</div><div class="line">truethis.age= age;</div><div class="line">truethis.job= job;</div><div class="line">truethis.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">trueconstructor:Person,</div><div class="line">truesayName:function()&#123;</div><div class="line">truetruealert(this.name);</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person(&quot;wanglin&quot;,25,&quot;front-end&quot;);</div><div class="line">var person2=new Person(&quot;wanglinzhizhi&quot;,24,&quot;front-end&quot;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">person1.friends.push(&quot;wanglinzhizhi&quot;);</div><div class="line">alert(person1.friends);	//&quot;Shelby,Court wanglinzhizhi&quot;</div><div class="line">alert(person2.friends);	//&quot;Shelby,Court&quot;</div><div class="line"></div><div class="line">alert(person1.friends===person2.friends);//true</div></pre></td></tr></table></figure>
<p>这种方式,用构造函数和原型混成的模式,是目前在ECMAScript 中使用<strong>最广泛,认同度最高的一种创建自定义类型的方法</strong>.可以说,这是用来<strong>定义引用类型的一种默认模式</strong>.</p>
<p><br><br><br><br></p>
<p>###　5.动态原型模式</p>
<p>动态原型模式,它把所有信息都封装在了构造函数中.而通过在构造函数中国初始化原型(仅仅在有必要的情况下),又保持了同时使用构造函数和原型的优点.换句话说,可以通过检查某个应该存在的方法是否有效,来决定是否需要初始化原型.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">true//属性</div><div class="line">truethis.name= name;</div><div class="line">truethis.age= age;</div><div class="line">truethis.job= job;</div><div class="line">true//方法</div><div class="line">trueif (typeof this.sayName  != &quot;function&quot;) &#123;</div><div class="line">truetruePerson.prototype.sayName=function()&#123;</div><div class="line">truetruetrueconsole.log(this.name);</div><div class="line">truetrue&#125;</div><div class="line">true&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person(&quot;wanglinzhizhi&quot;, 24, &quot;front-end&quot;);</div><div class="line">person1.sayName();</div></pre></td></tr></table></figure>
<p><br><br><br><br></p>
<h3 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6.寄生构造函数模式"></a>6.寄生构造函数模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">truevar obj=new Object();</div><div class="line">trueobj.name=name;</div><div class="line">trueobj.age=age;</div><div class="line">trueobj.job=job;</div><div class="line">trueobj.sayName=function()&#123;</div><div class="line">truetruetrueconsole.log(this.name);</div><div class="line">truetrue&#125;</div><div class="line">true&#125;;</div><div class="line"></div><div class="line">trueretrun obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person(&quot;wanglinzhizhi&quot;, 24, &quot;front-end&quot;);</div><div class="line">person1.sayName();</div></pre></td></tr></table></figure>
<p>这个模式可以在特殊的情况下用来为对象创建构造函数.假设我们需要创建一个具有额外方法的特殊数组.由于不能直接用Array构造函数,因此可以使用这个模式.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function SpecialArray() &#123;</div><div class="line">true//创建数组</div><div class="line">truevar values=new Array();</div><div class="line">true//添加值</div><div class="line">truevalues.push.apply(values,arguments);</div><div class="line">true//添加方法</div><div class="line">truevalues.toPipedString = function()&#123;</div><div class="line">truetruereturn this.join(&quot; | &quot;);</div><div class="line">true&#125;;</div><div class="line"></div><div class="line">true//返回数组</div><div class="line">truereturn values;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var colors=new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);</div><div class="line">console.log(colors.toPipedString());	// &quot;red|blue|green&quot;</div></pre></td></tr></table></figure>
<p>关于寄生构造函数模式,需要说明:首先,返回的对象与构造函数还活着与构造函数的原型属性之间没有任何关系,也就是说,构造函数返回的对象与在构造函数外部创建没什么区别.为此不能依赖instanceof 操作符来确定对象类型. 由于存在这个问题, 建议在可以使用其他模式的情况下,不要使用这种模式.</p>
<p><br><br><br><br></p>
<h3 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7.稳妥构造函数模式"></a>7.稳妥构造函数模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">truevar obj=new Object();</div><div class="line">trueobj.name=name;</div><div class="line">trueobj.age=age;</div><div class="line">trueobj.job=job;</div><div class="line">trueobj.sayName=function()&#123;</div><div class="line">truetruetrueconsole.log(name);</div><div class="line">truetrue&#125;</div><div class="line">true&#125;;</div><div class="line"></div><div class="line">trueretrun obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=new Person(&quot;wanglinzhizhi&quot;, 24, &quot;front-end&quot;);</div><div class="line">person1.sayName();</div><div class="line"></div><div class="line"></div><div class="line">//区别于寄生构造函数模式,</div></pre></td></tr></table></figure>
<hr>





<p><br><br><br><br></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>许多OO语言都支持两种继承方式: 接口继承和实现继承. 接口继承只继承方法签名, 而实现继承则继承实际的方法. 函数没有签名. 在ECMAScript 中 无法实现接口继承.ECMAScript只支持实现继承, 而且其实现继承主要依靠原型链来实现的.</p>
<p><br><br><br><br></p>
<h3 id="1原型继承"><a href="#1原型继承" class="headerlink" title="#1原型继承"></a>#1原型继承</h3><h3 id="谨慎的定义方法"><a href="#谨慎的定义方法" class="headerlink" title="谨慎的定义方法"></a>谨慎的定义方法</h3><p>子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">truethis.property= true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperTypeValue=function()&#123;</div><div class="line">trueretrun this.property;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">truethis.subproperty =  false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承，本质上 用SuperType的实例替换SubType的原型</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">//add new methods</div><div class="line">SubType.prototype.getSubValue= function()&#123;</div><div class="line">trueretrun this.subproperty;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重写超类型中的方法</div><div class="line">SubType.prototype.getSuperTypeValue=function()&#123;</div><div class="line">trueretrun false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance=new SubType();</div><div class="line">console.log(instance.getSuperTypeValue());	//false</div></pre></td></tr></table></figure>
<p>getSuperTypeValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。</p>
<p>换句话说，当SubType的实例调用getSuperTypeValue()时，调用的就是这个重新定义的方法，但通过SuperType的实例调用getSuperTypeValue()方法时，还会继续调用原来的那个方法。</p>
<p>这里格外要注意的是，必须在用SuperType 的实例替换原型之后，再定义这两个方法。要先new.在设置属性或方法.</p>
<p><br><br><br><br></p>
<h3 id="原型链继承的问题"><a href="#原型链继承的问题" class="headerlink" title="原型链继承的问题"></a>原型链继承的问题</h3><p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。 最主要的问题来自于包含引用类型值的原型。我们知道包含引用类型的原型属性会被所有实例所共享；而这也正是为什么要在构造函数中，而不是在原型中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺利成章地变成了现在的原型属性了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">truethis.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了SuperType</div><div class="line">SubType.prototype=new SuperType();</div><div class="line"></div><div class="line">var instance1= new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line"></div><div class="line">var instance2=new SubType();</div><div class="line">console.log(instance2.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div></pre></td></tr></table></figure>
<p>原型链的第二个问题:在创建子类的实例时,不能像超类的构造函数中传递参数.实际上,应该说是没有办法在不影响所有对象实例的情况下,给超类型的构造函数传递参数.鉴于此,再加上前面说的原型中对包含引用类型的值所带来的问题,在实践中我们很少会单独使用原型链.</p>
<p><br><br><br><br></p>
<h3 id="2借用构造函数-继承"><a href="#2借用构造函数-继承" class="headerlink" title="#2借用构造函数 继承"></a>#2借用构造函数 继承</h3><p>借用构造函数,也成为伪造对象或经典继承. 这种技术的基本思想相当简单, 即在子类型构造函数的内部 调用 超类型的构造函数.函数只不过是在特定环境中执行代码的对象,因此可以通过使用apply()和call() 方法也可在(将来)新创建的对象上执行构造函数.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">truethis.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//子类的构造函数中.</div><div class="line">function SubType()&#123;</div><div class="line">true// 在构造函数中，继承了SuppperType</div><div class="line">trueSuperType.call(this);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var instance1= new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line"></div><div class="line">var instance2=new SubType();</div><div class="line">console.log(instance2.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</div></pre></td></tr></table></figure>
<p>代码中，我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数，这样一来，就会在新SubType上执行SuperType()函数中定义的所有对象初始化代码.结果,SubType的每个实例就都会具有自己的color属性的副本了.</p>
<p>只借用构造函数的问题: 那么无法避免构造函数模式存在的问题,方法都在构造函数中定义,因此函数复用性就无从谈起了.而且,在超类的原型中定义的方法,对子类ixngeryan也是不可见的,结果所有类型都只能使用构造函数模式.</p>
<p><br><br><br><br></p>
<h3 id="3组合继承-伪经典继承"><a href="#3组合继承-伪经典继承" class="headerlink" title="#3组合继承.(伪经典继承)"></a>#3组合继承.(伪经典继承)</h3><p>思路是将原型链和借用构造函数的技术组合在一起.使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承.这样,级通过在原型上定义方法实现了函数复用,又能够保证每个实例都有自己的属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">function SuperType(name) &#123;</div><div class="line">truethis.name=name;</div><div class="line">truethis.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">trueconsole.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">true//继承属性</div><div class="line">trueSuperType.call(this,name);</div><div class="line"></div><div class="line">true//自己的属性</div><div class="line">truethis.age=age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//通过原型链来继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=function()&#123;</div><div class="line">trueconsole.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1=new SubType(&quot;wanglinzhizhi&quot;,24);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1.colors);</div><div class="line">instance1.sayName();</div><div class="line">instance1.sayAge();</div><div class="line"></div><div class="line">var instance2=new SubType(&quot;wanglin&quot;,25);</div><div class="line">console.log(instance2.colors);</div><div class="line">instance2.sayName();</div><div class="line">instance2.sayAge();</div></pre></td></tr></table></figure>
<p>组合继承，避免了原型链和借用构造函数的缺陷，融合了它们 的优点，成为JavaScript中最常用的继承模式。而且，instanceof 和 isPrototypeof() 也能够用于识别给予组合继承创建的对象。</p>
<p><br><br><br><br></p>
<h3 id="4原型式继承"><a href="#4原型式继承" class="headerlink" title="#4原型式继承"></a>#4原型式继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">function object(o)&#123;</div><div class="line">truefunction F()&#123;&#125;;</div><div class="line">trueF.prototype=o;</div><div class="line">truereturn new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先在object()函数内部,先创建一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的新实例. 本质上讲,object() 对传入其中的对象执行了一次浅复制.</p>
<p>ECMAScript5 通过新增Object.create()方法规范化了原型式继承.这个方法接受两个参数:1个用作新对象原型的对象和(可选的)1个为新对象定义额外属性的对象.在传入1个参数的情况下,object()和Object.create() 方法的行为相同.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var person=&#123;</div><div class="line">truename:&quot;wanglinzhizhi&quot;,</div><div class="line">truefriends:[&quot;luozhen1&quot;,&quot;luozhen2&quot;,&quot;luozhen3&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson=Object.create(person);</div><div class="line">anotherPerson.name=&quot;wanglin2&quot;;</div><div class="line">anotherPerson.friends.push(&quot;luozhen4&quot;);</div><div class="line"></div><div class="line">var anotherPerson2=Object.create(person);</div><div class="line">anotherPerson2.name=&quot;wanglin33&quot;;</div><div class="line">anotherPerson2.friends.push(&quot;luozhen5&quot;);</div><div class="line"></div><div class="line">console.log(person.friends);</div></pre></td></tr></table></figure>
<p>进一步简写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var person=&#123;</div><div class="line">truename:&quot;wanglinzhizhi&quot;,</div><div class="line">truefriends:[&quot;luozhen1&quot;,&quot;luozhen2&quot;,&quot;luozhen3&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson=Object.create(preson,&#123;</div><div class="line">truename:&#123;</div><div class="line">truetruevalue:&quot;wanglinzhzihi5555&quot;</div><div class="line">true&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(anotherPerson.name);//wanglinzhzihi5555</div></pre></td></tr></table></figure>
<p>在没有必要兴师动众地创建构造函数,而只想让一个对象与另一个对象保持类似的情况下,原型式继承是完全可以胜任的. 不过需要留意, 包含引用类型值的属性始终都会共享相应的值,就像使用原型模式一样.</p>
<p><br><br><br><br></p>
<h3 id="5寄生式继承"><a href="#5寄生式继承" class="headerlink" title="#5寄生式继承"></a>#5寄生式继承</h3><p>寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function createAnoter(origianl)&#123;</div><div class="line">truevar clone = object(origianl);</div><div class="line">trueclone.sayHi=function ( ) &#123;</div><div class="line">truetrueconsole.log(&quot;hi&quot;);</div><div class="line">true&#125;</div><div class="line">truereturn clone;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var person=&#123;</div><div class="line">truename:&quot;wanglinzhizhi&quot;,</div><div class="line">truefriends:[&quot;luozhen1&quot;,&quot;luozhen2&quot;,&quot;luozhen3&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson=createAnoter(person);</div><div class="line">anotherPerson.sayHi();//hi</div></pre></td></tr></table></figure>
<p><br><br><br><br></p>
<h3 id="6寄生组合式继承"><a href="#6寄生组合式继承" class="headerlink" title="#6寄生组合式继承"></a>#6寄生组合式继承</h3><p>组合式继承是Javascript最常用的继承模式,不过,它也有不足. 组合继承最大的问题是无论什么情况下, 都会叼调用两次超类的构造函数:一次是在创建子类原型的时候, 另一次是在子类构造函数内部. 没错,子类型最终会包含超类型的全部实例属性, 但是我们不得不在调用子类型构造函数时重写这些属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">truethis.name=name;</div><div class="line">truethis.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">trueconsole.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">true//继承属性</div><div class="line">trueSuperType.call(this,name);				//第二次调用SuperType</div><div class="line"></div><div class="line">true//自己的属性</div><div class="line">truethis.age=age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//通过原型链来继承方法</div><div class="line">SubType.prototype = new SuperType();		//第一次调用SuperType</div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=function()&#123;</div><div class="line">trueconsole.log(this.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓寄生组合式继承, 级即通过借用构造函数来继承属性, 通过原型链的混成形式来继承方法.基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数, 我们所需的无非是操类型的原型的一个副本而已. 本质上, 就是使用寄生式继承来继承超类型的原型, 然后再将结果指定给子类型的原型.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function inheritPrototype(subType,superType) &#123;</div><div class="line">truevar prototype=Object(SuperType.prototype);//创建对象</div><div class="line">true//等价于 var prototype=Object.create(superType.prototype);</div><div class="line"></div><div class="line"></div><div class="line">true//下面两行完成原型链的链接,其实本质上就是两个List节点的拼接.</div><div class="line">trueprototype.constructor = subType;		//增强对象</div><div class="line">truesubType.prototype = prototype;			//指定对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SuperType(name) &#123;</div><div class="line">truethis.name=name;</div><div class="line">truethis.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">trueconsole.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">true//继承属性</div><div class="line">trueSuperType.call(this,name);				</div><div class="line">true//自己的属性</div><div class="line">truethis.age=age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 寄生组合继承.</div><div class="line">inheritPrototype(subType,SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge=function()&#123;</div><div class="line">trueconsole.log(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其高效性体现在 它只调用了一次SuperType构造函数，并且因此避免了在superType.prototype上面创建不必要的,多余的属性.同时,原型链还能保持不变;因此,还能正常使用 instanceof 和 isPrototypeOf().</p>
<p>开发人员普遍认为 <strong>寄生组合继承 是引用类型最为理想的继承范式</strong>.(YAHOO.lang.extend()方法运用了寄生组合继承.)</p>

	
	
	
	
</div>
				
				

                <!-- Post Comments -->
                
                    


                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    
    <!-- Prev Nav -->
    
        <a href="/2016/02/16/2016-02-16-求生本能/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2016/02/08/2016-02-08-一次HTTP请求过程/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>
        </div>
    </div>

				
				
					<!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay "></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored  sidebar-fixed-left" role="navigation">
	<div id="sidebar-main">
	    <!-- Sidebar Header -->
		<div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
    <i class="material-icons">clear_all</i>
    <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/me.jpeg" alt="wanglinzhizhi's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        wanglinzhizhi@hotmail.com
        <b class="caret"></b>
    </a>
</div>

		<!-- Sidebar Navigation  -->
		<ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
			
                <li>
                    <a href="#" target="_blank" title="Email Me">
						<i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    <li id="sidebar-first-li">
        <a href="/" target="_self">
            <i class="material-icons sidebar-material-icons">home</i>
             主页
        </a>
    </li>

    <!-- I'm Feeling Lucky -->
<!--
    <li class="dropdown">
        <a href="" target="_self">
            <i class="material-icons sidebar-material-icons">explore</i>
             sidebar.imlucky
        </a>
    </li>
-->

	
    <!-- Archives  -->
    <li class="dropdown">
        <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
            <i class="material-icons sidebar-material-icons">inbox</i>
             归档
            <b class="caret"></b>
        </a>
        <ul class="dropdown-menu">
            <li>
            <a class="sidebar_archives-link" href="/archives/2017/01/">January 2017<span class="sidebar_archives-count">74</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/02/">February 2016<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/01/">January 2016<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/12/">December 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/08/">August 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/06/">June 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/04/">April 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/03/">March 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/01/">January 2015<span class="sidebar_archives-count">1</span></a>
        </ul>
    </li>

    <!-- Divider -->
    <li class="divider"></li>


    <!-- Pages  -->
	
		<li>
			<a href="/tags" title="Tags">
				Tags
			</a>
		</li>
	
		<li>
			<a href="/gallery" title="Gallery">
				Gallery
			</a>
		</li>
	
		<li>
			<a href="/about" title="About">
				About
			</a>
		</li>
	

    <!-- Article Numebr  -->
    <li>
        <a href="/archives">
             文章总数
             <span class="sidebar-badge">88</span>
        </a>
    </li>
</ul>

		<!-- Sidebar Divider -->
		<div class="sidebar-divider"></div>

		<!-- Sidebar Footer -->
		<!-- 
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持。 :) 
-->

<!-- Theme Material -->
<a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
	<div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
		主题 - Material
		<span class="sidebar-badge badge-circle">i</span>
	</div>
</a>

<!-- Help & Support -->
<!--
<a href="mailto:hiviosey@gmail.com" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
		sidebar.help
		<span class="mdl-button__ripple-container">
			<span class="mdl-ripple"></span>
		</span>
	</div>
</a>
-->

<!-- Feedback -->
<!--
<a href="https://github.com/viosey/hexo-theme-material/issues" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.feedback
                    <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>
-->

<!-- Abount Theme -->
<!--
<a href="https://blog.viosey.com/index.php/Material.html" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.about_theme
        <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>-->

	</div>
    
    <!-- Sidebar Sponsor -->
    


</aside>

				
				
				
					<!-- Footer Top Button -->
					<div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>
				
				
				<!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
	
	
		<!-- Paradox Footer Left Section -->
		<div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
    
    
    <!-- Facebook -->
    
    
    
    <!-- Google + -->
    
    
    
    <!-- Weibo -->
    
    
    
    <!-- Instagram -->
    
    
    
    <!-- Tumblr -->
    
    
    
    <!-- Github -->
    
    <a href="https://github.com/wagnlinzh" target="view_window"><button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-github.png);">
        <span class="visuallyhidden">Github</span>
    </button></a>
    
</div>


		<!--Copyright-->
		<div id="copyright">Copyright&nbsp;©&nbsp;<script type="text/javascript">var fd = new Date();document.write(fd.getFullYear());</script>&nbsp;wanglinzhizhi</div>

		<!-- Paradox Footer Right Section -->

		<!-- 
		I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
		It will not impact the appearance and can give developers a lot of support :)

		很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
		它不会影响美观并可以给开发者很大的支持。 :) 
		-->

		<div class="mdl-mini-footer--right-section">
			<div>
				<div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
				<div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
			</div>
		</div>
	
    
</footer>
                
				<!-- Import File -->
<script src="/js/highlight.min.js"></script>
<script src="/js/js.min.js"></script>
<script src="/js/nprogress.js"></script>

<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    
    $('#nprogress .bar').css({
        'background': '#FF4081'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #FF4081, 0 0 15px #FF4081'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#FF4081',
        'border-left-color': '#FF4081'
    });
    
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>


	<script src="/js/smoothscroll.js"></script>



    <!-- Leancloud -->
	<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
	<script>
		AV.initialize("EObBAbqpQfNFLuV5SjbVgoxq-gzGzoHsz", "qPdmjfSU3DDmPPH9ui0cUW4z");
	</script>
    <script>
	function showTime(Counter) {
		var query = new AV.Query(Counter);
		$(".leancloud-views_num").each(function() {
			var url = $(this).attr("id").trim();
			query.equalTo("url", url);
			query.find({
				success: function(results) {
					if (results.length == 0) {
						var content = '0 ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
						return;
					}
					for (var i = 0; i < results.length; i++) {
						var object = results[i];
						var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					}
				},
				error: function(object, error) {
					console.log("Error: " + error.code + " " + error.message);
				}
			});

		});
	}

	function addCount(Counter) {
		var Counter = AV.Object.extend("Counter");
		url = $(".leancloud-views_num").attr('id').trim();
		title = $(".leancloud-views_num").attr('data-flag-title').trim();
		var query = new AV.Query(Counter);
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length > 0) {
					var counter = results[0];
					counter.fetchWhenSave(true);
					counter.increment("time");
					counter.save(null, {
						success: function(counter) {
							var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
							$(document.getElementById(url)).text(content);
						},
						error: function(counter, error) {
							console.log('Failed to save Visitor num, with error message: ' + error.message);
						}
					});
				} else {
					var newcounter = new Counter();
					newcounter.set("title", title);
					newcounter.set("url", url);
					newcounter.set("time", 1);
					newcounter.save(null, {
						success: function(newcounter) {
							console.log("newcounter.get('time')="+newcounter.get('time'));
							var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
							$(document.getElementById(url)).text(content);
						},
						error: function(newcounter, error) {
							console.log('Failed to create');
						}
					});
				}
			},
			error: function(error) {
				console.log('Error:' + error.code + " " + error.message);
			}
		});
	}
	$(function() {
		var Counter = AV.Object.extend("Counter");
		if ($('.leancloud-views_num').length == 1) {
			addCount(Counter);
		} else if ($('.post-title-link').length > 1) {
			showTime(Counter);
		}
	}); 
</script>








<!-- Swiftye -->


<!-- Local Search-->

	<script>
	var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        success: function( xmlResponse ) {
            // get the contents from search data
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length <= 0) {
                    return;
                }
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        str += "<li><a href='"+ data_url +"' class='search-result-title' target='_blank'>"+ data_title;
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out characters
                            var start = first_occur - 6;
                            var end = first_occur + 6;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 10;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substr(start, end); 
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<em class=\"search-keyword\">"+keyword+"</em>");
                            })
                            str += "<p class=\"search-result\">" + match_content +"...</p>" +"</a>";
                        }
                    }
                })
                $resultContent.innerHTML = str;
            })
        }
    })
}
</script>

	<script>
        var inputArea = document.querySelector("#search");
        var getSearchFile = function(){
            var path = "search.xml";
            searchFunc(path, 'search', 'local-search-result');
        }

        inputArea.onfocus = function(){ getSearchFile() }
	</script>


<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $(".post-toc-wrap").parent(".mdl-menu__container").css("position", "fixed");
    });
</script>

<!-- MathJax Load-->

            </main>
        </div>
		
    </body>
		
	
</html>
